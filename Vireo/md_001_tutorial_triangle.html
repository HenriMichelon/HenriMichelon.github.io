<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="DoxyPress 1.7.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vireo RHI: Vireo RHI &quot;Hello Triangle&quot; tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vireo RHI
      &#160;<span id="projectnumber">v0.0</span>
   </div>
   <div id="projectbrief">Vireo Rendering Hardware Interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.7.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Documentation</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
    <div class="title">Vireo RHI "Hello Triangle" tutorial </div>
  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>This tutorial will teach you the basics of using the Vireo Rendering Hardware Interface. Vireo is an open source library written in modern C++ that implements a common abstraction layer over multiple 3D graphics APIs.</p>
<p>Like modern graphics API, Vireo is a low-level library but is designed to be less verbose, at the price of reduced flexibility.</p>
<p>This tutorial assumes that the reader already knows the basic concepts of the modern graphics API like Vulkan or DirectX 12, like pipelines, descriptors, resources, buffers, barriers, ...</p>
<h2>Development environment</h2>
<p>Since Vireo currently only supports Microsoft Windows this tutorial assumes that you use this operating system.</p>
<p>We will be using CMake which means that you can use <a href="https://visualstudio.microsoft.com/fr/">Microsoft Visual Studio</a> or <a href="https://www.jetbrains.com/clion/">Jetbrains CLion</a> to edit and compile your code. Note that you need to install the CMake component for Visual Studio.</p>
<p>Since Vireo implements a DirectX 12 backend under Windows you need to install <a href="https://visualstudio.microsoft.com/fr/">Microsoft Visual C++ 2022 (MSCV 19+)</a>. Vireo can be compiled with LLVM but only with the Vulkan back-end alone.</p>
<p>For DirectX 12 install the "Game Development with C++" component for Visual Studio.</p>
<p>For Vulkan install the <a href="https://vulkan.lunarg.com/">Vulkan SDK</a></p>
<p>The CMake scripts will automatically install the <a href="https://github.com/g-truc/glm">GLM</a> library used in this tutorial</p>
<p>Finally, clone <a href="https://github.com/HenriMichelon/vireo_rhi">the Vireo RHI repository</a> somewhere in your computer.</p>
<h2>Setting up the project</h2>
<p>Clone the <a href="https://github.com/HenriMichelon/vireo_template">Vireo template project</a> somewhere in your computer then adds a <code>.env.cmake</code> file containing the following variable at the root of your project: </p><pre class="fragment">set(VIREO_PROJECT_DIR "path_to_the_cloned_vireo_directory")
</pre><p> In the <code>src</code> directory creates :</p>
<p>A new <code>MyApp.ixx</code> interface file for your application : </p><pre class="fragment">module;
#include "Libraries.h"
export module myapp;

import app;

export class MyApp : public Application {
public:
    void onInit() override;
    void onRender() override;
    void onResize() override;
    void onDestroy() override;
}
</pre><p> A new <code>MyApp.cpp</code> implementation file : </p><pre class="fragment">module;
#include "Libraries.h"
module myapp;

void MyApp::onInit() {
}

void MyApp::onRender() {
}

void MyApp::onResize() {
}

void MyApp::onDestroy() {
}
</pre><p> And a new <code>MyAppMain.cpp</code> source file : </p><pre class="fragment">#include "Macros.h"
import myapp;

APP(std::make_shared&lt;MyApp&gt;(), L"Hello, Vireo !", 1280, 720);
</pre><p> Update the <code>CMakeLists.txt</code> file by uncommenting the last part : </p><pre class="fragment">...

#######################################################
set(MY_TARGET_SRC
        ${SRC_DIR}/MyApp.cpp
        ${SRC_DIR}/MyAppMain.cpp)
set(MY_TARGET_MODULES ${SRC_DIR}/MyApp.ixx)
build_target(myapp "${MY_TARGET_SRC}" ${MY_TARGET_MODULES})
</pre><p> Then reload the CMake project and build the <code>myapp</code> target.</p>
<p>Execute the application (from the project root directory), it will display the graphic API selection dialog :</p>
<div class="image">
<img src="backend_select.png" alt=""/>
<div class="caption">
backend_select.png</div></div>
    <p>Select an API and an empty window will be displayed :</p>
<div class="image">
<img src="empty_window.png" alt=""/>
<div class="caption">
empty_window.png</div></div>
    <h2>The Vireo class</h2>
<p>The <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1Vireo.html">Vireo</a> class encapsulate the creation of the various objects needed by the graphics API such as the physical adapter and the logical device. The instance of the <code>Vireo</code> class is stored in the <code>vireo</code> field of the base <code>Application</code> class of your project. The creation of the instance is done in the os-specific main class (<code>Win32Application</code> for Windows) of your project after the user selects the runtime backend :</p>
<div class="image">
<img src="backend_select.png" alt=""/>
<div class="caption">
backend_select.png</div></div>
    <p>The <code>Vireo</code> class is the main class of the library; You need an instance of this class to create all the library objects.</p>
<h2>The submission queue</h2>
<p>Most operations performed with graphics API, like draw commands and memory operations, are asynchronously executed by submitting them to a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1SubmitQueue.html">SubmitQueue</a>. Queues are allocated from <a href="https://henrimichelon.github.io/Vireo/namespacevireo.html#a21e038f5b8958e203d28bc4f18472352">command types</a>, where each type supports a specific set of operations in its queues. For example, there could be separate queue families for graphics, compute and memory transfer operations.</p>
<p>Add a submission queue field to your application : </p><pre class="fragment">...
private:
    std::shared_ptr&lt;vireo::SubmitQueue&gt; graphicQueue;
};
</pre><p> This queue will be used for all graphics commands and for presenting the result in the window.</p>
<p>Create it in the <code>onInit()</code> method : </p><pre class="fragment">void MyApp::onInit() {
    graphicQueue = vireo-&gt;createSubmitQueue(vireo::CommandType::GRAPHIC);
}
</pre><p> and in the <code>onDestroy()</code> method add the code to wait for all the submitted commands to finish before closing the application : </p><pre class="fragment">void MyApp::onDestroy() {
    graphicQueue-&gt;waitIdle();
}
</pre> <h2>The swap chain</h2>
<p>The swap chain is a collection of frame buffers. Its basic purpose is to ensure that the image that we're currently rendering to is different from the one that is currently on the screen. This is important to make sure that only complete images are shown. Every time we want to draw a frame we have to ask the swap chain to provide us with an image to render to. When we've finished drawing a frame, the image is returned to the swap chain for it to be presented to the screen at some point.</p>
<p>We need a synchronization mechanism when we use a swap chain since the modern graphics API executes commands asynchronously: we have to wait for the GPU to finish the submitted work before reusing a frame buffer.</p>
<p>The CPU/GPU synchronization is done with a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1Fence.html">Fence</a> object. Since we can have multiple frames in flight (the GPU can render in multiple frame buffers in parallel), we need one <code>Fence</code> per frame buffer.</p>
<p>Add a <code>FrameData</code> <code>struct</code> and a <code>vector</code> of <code>FrameData</code> to your application: </p><pre class="fragment">static constexpr auto FRAMES_IN_FLIGHT{2};
struct FrameData {
    std::shared_ptr&lt;vireo::Fence&gt; inFlightFence;
};
std::vector&lt;FrameData&gt; framesData{FRAMES_IN_FLIGHT};
</pre><p> Create the fences after the queue creation : </p><pre class="fragment">for (auto&amp; frameData : framesData) {
    frameData.inFlightFence = vireo-&gt;createFence();
}
</pre><p>It's time to create the swap chain. Add a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1SwapChain.html">SwapChain</a> field : </p><pre class="fragment">std::shared_ptr&lt;vireo::SwapChain&gt; swapChain;
</pre><p> We need the window handle to create the swap chain. The window is created by the <code>Win32Application</code> and the os-specific handle is stored in the <code>windowHandle</code> field of the base <code>Application</code> class. We can use this field to create the swap chain, just after the <code>graphicQueue</code> creation: </p><pre class="fragment">swapChain = vireo-&gt;createSwapChain(
    vireo::ImageFormat::R8G8B8A8_SRGB,
    graphicQueue,
    windowHandle,
    vireo::PresentMode::VSYNC,
    FRAMES_IN_FLIGHT);
</pre><p> The swap chain needs to be recreated each time the window is resized : </p><pre class="fragment">void MyApp::onResize() {
    swapChain-&gt;recreate();
}
</pre><p> We have to wait for the last frame presentation to be finished before closing the application : </p><pre class="fragment">void MyApp::onDestroy() {
    graphicQueue-&gt;waitIdle();
    swapChain-&gt;waitIdle();
}
</pre><p>Get the frame data corresponding to the current frame in the <code>onRender()</code> method, acquire the next frame buffer (while waiting for the frame buffer to be ready), then present it into the window : </p><pre class="fragment">void MyApp::onRender() {
    const auto&amp; frameData = framesData[swapChain-&gt;getCurrentFrameIndex()];
    if (!swapChain-&gt;acquire(frameData.inFlightFence)) { return; }

    // commands will be recorded and submitted here

    swapChain-&gt;present();
    swapChain-&gt;nextFrameIndex();
}
</pre> <h2>Commands allocators and command lists</h2>
<p>We can't execute the application now because the swap chain image needs to be ready to be presented by the GPU before calling <code>present()</code>. To make this frame buffer ready to be presented, we have to use a pipeline barrier to synchronize resource like image between the different stages of a GPU pipeline.</p>
<p>A pipeline barrier is a GPU synchronization primitive that guarantees that any writes performed by those earlier stages are made visible (and available) to reads or writes in the later stages.</p>
<p>A pipeline barrier is created on the GPU with the help of a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1CommandList.html">CommandList</a> and a command list is allocated by a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1CommandAllocator.html">CommandAllocator</a>.</p>
<p>The command list will also be used to record pipeline and drawing commands for execution by the GPU.</p>
<p>Since we can render multiple frames in flight, we need one allocator and one list per frame: </p><pre class="fragment">...
struct FrameData {
    std::shared_ptr&lt;vireo::Fence&gt;            inFlightFence;
    std::shared_ptr&lt;vireo::CommandAllocator&gt; commandAllocator;
    std::shared_ptr&lt;vireo::CommandList&gt;      commandList;
};
...
</pre><p> Add the creation code after the fence creation : </p><pre class="fragment">...
for (auto&amp; frameData : framesData) {
    frameData.inFlightFence = vireo-&gt;createFence();
    frameData.commandAllocator = vireo-&gt;createCommandAllocator(vireo::CommandType::GRAPHIC);
    frameData.commandList = frameData.commandAllocator-&gt;createCommandList();
}
</pre><p> Command lists need to be :</p><ul>
<li>Reset before use (via the command allocator in this tutorial)</li>
<li>Submitted to the GPU with a submission queue</li>
</ul>
<p>We will do that between <code>acquire()</code> and <code>present()</code>: </p><pre class="fragment">...
frameData.commandAllocator-&gt;reset();

// commands will be recorded and submitted here

graphicQueue-&gt;submit(
    frameData.inFlightFence,
    swapChain,
    {frameData.commandList});
...
</pre><p>Recording commands in the command list is done in a <em>recording session</em>. A session starts with <code>begin()</code> and ends with <code>end()</code>, between <code>reset()</code> and <code>submit()</code> : </p><pre class="fragment">...
frameData.commandList-&gt;begin();

// commands will be recorded and submitted here

frameData.commandList-&gt;end();
...
</pre><p> We can finally add the pipeline barriers for the current swap chain frame buffer between <code>begin()</code> and <code>end()</code>: </p><pre class="fragment">frameData.commandList-&gt;barrier(
    swapChain,
    vireo::ResourceState::UNDEFINED,
    vireo::ResourceState::RENDER_TARGET_COLOR);

// commands will be recorded and submitted here

frameData.commandList-&gt;barrier(
    swapChain,
    vireo::ResourceState::RENDER_TARGET_COLOR,
    vireo::ResourceState::PRESENT);
</pre><p> The application can be started to display a black window (since we never write data into the frame buffer): <img src="swap_chain.png" alt="" class="inline" title="swap_chain.png"/>    </p>
<h2>Render pass</h2>
<p>A render pass consists of a list of commands submitted to the GPU to draw into various frame buffers also named attachments. In this tutorial we will directly draw into the swap chain frame buffers.</p>
<p>To configure the attachments and the render pass we have to create a <a href="https://henrimichelon.github.io/Vireo/structvireo_1_1RenderingConfiguration.html">RenderingConfiguration</a>. Add a configuration object to your application class: </p><pre class="fragment">...
vireo::RenderingConfiguration renderingConfig {
    .colorRenderTargets = {{
        .clearColorValue = {0.0f, 0.2f, 0.4f, 1.0f}
    }}
};
...
</pre><p> We declare in this object <em>one</em> frame buffer as a color attachment. The only parameter for this attachment is the RGBA color used to clear the frame buffer before drawing (we need it to be different from the default black color to visually control that the frame buffer clearing is effective).</p>
<p>Since we will render directly into the swap chain we need to set the color attachment target just after the swap chain creation with <code>createSwapChain()</code>: </p><pre class="fragment">...
renderingConfig.colorRenderTargets[0].swapChain = swapChain;
...
</pre><p> In the <code>onRender()</code> method we can start the render pass between the swap chain barriers: </p><pre class="fragment">...
frameData.commandList-&gt;beginRendering(renderingConfig);

// commands will be recorded and submitted here

frameData.commandList-&gt;endRendering();
...
</pre><p> After the white then the black window we now have a blue window : <img src="clear_color.png" alt="" class="inline" title="clear_color.png"/>    </p>
<h2>Viewports and scissors</h2>
<p>A viewport basically describes the region of the framebuffer that the output will be rendered to. This will almost always be (0, 0) to (width, height).</p>
<p>While viewports define the transformation from the image to the framebuffer, scissor rectangles define in which regions pixels will actually be stored. Any pixels outside the scissor rectangles will be discarded by the rasterizer. They function like a filter rather than a transformation (image is from the <a href="https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions">Vulkan tutorial</a>):</p>
<div class="image">
<img src="viewports_scissors.png" alt=""/>
<div class="caption">
viewports_scissors.png</div></div>
    <p>We need to record the commands to set the viewports &amp; scissors at the start of the render pass : </p><pre class="fragment">...
frameData.commandList-&gt;beginRendering(renderingConfig);
frameData.commandList-&gt;setViewports(1, {swapChain-&gt;getExtent()});
frameData.commandList-&gt;setScissors(1, {swapChain-&gt;getExtent()});
// commands will be recorded and submitted here
...
</pre> </div></div><!-- contents -->
<!-- Generated by DoxyPress 1.7.0 -->
<hr class="footer"/><address class="footer"><small>
Generated on ven. avr. 25 2025 23:36:32 for Vireo RHI &nbsp; by &#160;<a href="https://www.copperspice.com/documentation-doxypress.html">
<img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.7.0
</small></address>
</body>
</html>
