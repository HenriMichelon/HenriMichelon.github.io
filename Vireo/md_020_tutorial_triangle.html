<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="DoxyPress 2.0.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vireo: Vireo RHI &quot;Hello Triangle&quot; tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vireo
      &#160;<span id="projectnumber">0.0</span>
   </div>
   <div id="projectbrief">Vireo 3D Rendering Hardware Interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 2.0.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="pages.html"><span>Documentation</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_020_tutorial_triangle.html',''); initResizable(); });
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
    <div class="title">Vireo RHI "Hello Triangle" tutorial </div>
  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>This tutorial will teach you the basics of using the Vireo Rendering Hardware Interface. Vireo is an open source library written in modern C++ that implements a common abstraction layer over multiple 3D graphics APIs.</p>
<p>Like modern graphics API, Vireo is a low-level library but is designed to be less verbose, at the price of reduced flexibility.</p>
<p>This tutorial assumes that the reader already knows the basic concepts of the modern graphics API like Vulkan or DirectX 12, like pipelines, descriptors, resources, buffers, barriers, ...</p>
<p>Sources of the tutorial are available at <a href="https://github.com/HenriMichelon/vireo_tutorial_1">https://github.com/HenriMichelon/vireo_tutorial_1</a></p>
<h2>Development environment</h2>
<p>Since Vireo currently only supports Microsoft Windows this tutorial assumes that you use this operating system.</p>
<p>We will be using CMake which means that you can use <a href="https://visualstudio.microsoft.com/fr/">Microsoft Visual Studio</a> or <a href="https://www.jetbrains.com/clion/">Jetbrains CLion</a> to edit and compile your code. Note that you need to install the CMake component for Visual Studio.</p>
<p>Since Vireo implements a DirectX 12 backend under Windows you need to install <a href="https://visualstudio.microsoft.com/fr/">Microsoft Visual C++ 2022 (MSCV 19+)</a>. Vireo can be compiled with LLVM but only with the Vulkan back-end alone.</p>
<p>For DirectX 12 install the "Game Development with C++" component for Visual Studio.</p>
<p>For Vulkan install the <a href="https://vulkan.lunarg.com/">Vulkan SDK</a></p>
<p>The CMake scripts will automatically install the <a href="https://github.com/g-truc/glm">GLM</a> library used in this tutorial</p>
<p>Finally, clone <a href="https://github.com/HenriMichelon/vireo_rhi">the Vireo RHI repository</a> somewhere in your computer.</p>
<h2>Setting up the project</h2>
<p>Clone the <a href="https://github.com/HenriMichelon/vireo_template">Vireo template project</a> somewhere in your computer then adds a <code>.env.cmake</code> file containing the following variable at the root of your project: </p><pre class="fragment">set(VIREO_PROJECT_DIR "path_to_the_cloned_vireo_directory")
</pre><p> In the <code>src</code> directory creates :</p>
<p>A new <code>MyApp.ixx</code> interface file for your application : </p><pre class="fragment">module;
#include "Libraries.h"
export module myapp;

import app;

export class MyApp : public Application {
public:
    void onInit() override;
    void onRender() override;
    void onResize() override;
    void onDestroy() override;
}
</pre><p> A new <code>MyApp.cpp</code> implementation file : </p><pre class="fragment">module;
#include "Libraries.h"
module myapp;

void MyApp::onInit() {
}

void MyApp::onRender() {
}

void MyApp::onResize() {
}

void MyApp::onDestroy() {
}
</pre><p> And a new <code>MyAppMain.cpp</code> source file : </p><pre class="fragment">#include "Macros.h"
import myapp;

APP(std::make_shared&lt;MyApp&gt;(), L"Hello, Vireo !", 1280, 720);
</pre><p> Update the <code>CMakeLists.txt</code> file by uncommenting the last part : </p><pre class="fragment">...

#######################################################
set(MY_TARGET_SRC
        ${SRC_DIR}/MyApp.cpp
        ${SRC_DIR}/MyAppMain.cpp)
set(MY_TARGET_MODULES ${SRC_DIR}/MyApp.ixx)
build_target(myapp "${MY_TARGET_SRC}" ${MY_TARGET_MODULES})
</pre><p> Then reload the CMake project and build the <code>myapp</code> target.</p>
<p>Execute the application (from the project root directory), it will display the graphic API selection dialog :</p>
<div class="image">
<img src="backend_select.png" alt=""/>
<div class="caption">
backend_select.png</div></div>
    <p>Select an API and an empty window will be displayed :</p>
<div class="image">
<img src="empty_window.png" alt=""/>
<div class="caption">
empty_window.png</div></div>
    <h2>The Vireo class</h2>
<p>The <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1Vireo.html">Vireo</a> class encapsulate the creation of the various objects needed by the graphics API such as the physical adapter and the logical device. The instance of the <code>Vireo</code> class is stored in the <code>vireo</code> field of the base <code>Application</code> class of your project. The creation of the instance is done in the os-specific main class (<code>Win32Application</code> for Windows) of your project after the user selects the runtime backend :</p>
<div class="image">
<img src="backend_select.png" alt=""/>
<div class="caption">
backend_select.png</div></div>
    <p>The <code>Vireo</code> class is the main class of the library; You need an instance of this class to create all the library objects.</p>
<h2>The submission queue</h2>
<p>Most operations performed with graphics API, like draw commands and memory operations, are asynchronously executed by submitting them to a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1SubmitQueue.html">SubmitQueue</a>. Queues are allocated from <a href="https://henrimichelon.github.io/Vireo/namespacevireo.html#a21e038f5b8958e203d28bc4f18472352">command types</a>, where each type supports a specific set of operations in its queues. For example, there could be separate queue families for graphics, compute and memory transfer operations.</p>
<p>Add a submission queue field to your application : </p><pre class="fragment">...
private:
    std::shared_ptr&lt;vireo::SubmitQueue&gt; graphicQueue;
};
</pre><p> This queue will be used for all graphics commands and for presenting the result in the window.</p>
<p>Create it in the <code>onInit()</code> method : </p><pre class="fragment">void MyApp::onInit() {
    graphicQueue = vireo-&gt;createSubmitQueue(vireo::CommandType::GRAPHIC);
}
</pre><p> and in the <code>onDestroy()</code> method add the code to wait for all the submitted commands to finish before closing the application : </p><pre class="fragment">void MyApp::onDestroy() {
    graphicQueue-&gt;waitIdle();
}
</pre> <h2>The swap chain</h2>
<p>The swap chain is a collection of frame buffers. Its basic purpose is to ensure that the image that we're currently rendering to is different from the one that is currently on the screen. This is important to make sure that only complete images are shown. Every time we want to draw a frame we have to ask the swap chain to provide us with an image to render to. When we've finished drawing a frame, the image is returned to the swap chain for it to be presented to the screen at some point.</p>
<p>We need a synchronization mechanism when we use a swap chain since the modern graphics API executes commands asynchronously: we have to wait for the GPU to finish the submitted work before reusing a frame buffer.</p>
<p>The CPU/GPU synchronization is done with a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1Fence.html">Fence</a> object. Since we can have multiple frames in flight (the GPU can render in multiple frame buffers in parallel), we need one <code>Fence</code> per frame buffer.</p>
<p>Add a <code>FrameData</code> <code>struct</code> and a <code>vector</code> of <code>FrameData</code> to your application: </p><pre class="fragment">static constexpr auto FRAMES_IN_FLIGHT{2};
struct FrameData {
    std::shared_ptr&lt;vireo::Fence&gt; inFlightFence;
};
std::vector&lt;FrameData&gt; framesData{FRAMES_IN_FLIGHT};
</pre><p> Create the fences after the queue creation in the <code>onInit()</code> method : </p><pre class="fragment">for (auto&amp; frameData : framesData) {
    frameData.inFlightFence = vireo-&gt;createFence(true);
}
</pre><p>It's time to create the swap chain. Add a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1SwapChain.html">SwapChain</a> field to your application interface: </p><pre class="fragment">std::shared_ptr&lt;vireo::SwapChain&gt; swapChain;
</pre><p> We need the window handle to create the swap chain. The window is created by the <code>Win32Application</code> and the os-specific handle is stored in the <code>windowHandle</code> field of the base <code>Application</code> class. We can use this field to create the swap chain, just after the <code>graphicQueue</code> creation, in the <code>onInit()</code> method : </p><pre class="fragment">swapChain = vireo-&gt;createSwapChain(
    vireo::ImageFormat::R8G8B8A8_SRGB,
    graphicQueue,
    windowHandle,
    vireo::PresentMode::VSYNC,
    FRAMES_IN_FLIGHT);
</pre><p> The swap chain needs to be recreated each time the window is resized : </p><pre class="fragment">void MyApp::onResize() {
    swapChain-&gt;recreate();
}
</pre><p> We have to wait for the last frame presentation to be finished before closing the application : </p><pre class="fragment">void MyApp::onDestroy() {
    graphicQueue-&gt;waitIdle();
    swapChain-&gt;waitIdle();
}
</pre><p>Get the frame data corresponding to the current frame in the <code>onRender()</code> method, acquire the next frame buffer (while waiting for the frame buffer to be ready), then present it into the window : </p><pre class="fragment">void MyApp::onRender() {
    const auto&amp; frameData = framesData[swapChain-&gt;getCurrentFrameIndex()];
    if (!swapChain-&gt;acquire(frameData.inFlightFence)) { return; }

    // commands will be recorded and submitted here

    swapChain-&gt;present();
    swapChain-&gt;nextFrameIndex();
}
</pre> <h2>Commands allocators and command lists</h2>
<p>We can't execute the application now because the swap chain image needs to be ready to be presented by the GPU before calling <code>present()</code>. To make this frame buffer ready to be presented, we have to use a pipeline barrier to synchronize resource like image between the different stages of a GPU pipeline.</p>
<p>A pipeline barrier is a GPU synchronization primitive that guarantees that any writes performed by those earlier stages are made visible (and available) to reads or writes in the later stages.</p>
<p>A pipeline barrier is created on the GPU with the help of a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1CommandList.html">CommandList</a> and a command list is allocated by a <a href="https://henrimichelon.github.io/Vireo/classvireo_1_1CommandAllocator.html">CommandAllocator</a>.</p>
<p>The command list will also be used to record pipeline and drawing commands for execution by the GPU.</p>
<p>Since we can render multiple frames in flight, we need one allocator and one list per frame: </p><pre class="fragment">...
struct FrameData {
    std::shared_ptr&lt;vireo::Fence&gt;            inFlightFence;
    std::shared_ptr&lt;vireo::CommandAllocator&gt; commandAllocator;
    std::shared_ptr&lt;vireo::CommandList&gt;      commandList;
};
...
</pre><p> Add the creation code after the fence creation : </p><pre class="fragment">...
for (auto&amp; frameData : framesData) {
    frameData.inFlightFence = vireo-&gt;createFence(true);
    frameData.commandAllocator = vireo-&gt;createCommandAllocator(vireo::CommandType::GRAPHIC);
    frameData.commandList = frameData.commandAllocator-&gt;createCommandList();
}
</pre><p> Command lists need to be :</p><ul>
<li>Reset before use (via the command allocator in this tutorial)</li>
<li>Submitted to the GPU with a submission queue</li>
</ul>
<p>We will do that between <code>acquire()</code> and <code>present()</code>: </p><pre class="fragment">...
frameData.commandAllocator-&gt;reset();

// commands will be recorded and submitted here

graphicQueue-&gt;submit(
    frameData.inFlightFence,
    swapChain,
    {frameData.commandList});
...
</pre><p>Recording commands in the command list is done in a <em>recording session</em>. A session starts with <code>begin()</code> and ends with <code>end()</code>, between <code>reset()</code> and <code>submit()</code> : </p><pre class="fragment">...
frameData.commandList-&gt;begin();

// commands will be recorded and submitted here

frameData.commandList-&gt;end();
...
</pre><p> We can finally add the pipeline barriers for the current swap chain frame buffer between <code>begin()</code> and <code>end()</code>: </p><pre class="fragment">frameData.commandList-&gt;barrier(
    swapChain,
    vireo::ResourceState::UNDEFINED,
    vireo::ResourceState::RENDER_TARGET_COLOR);

// commands will be recorded and submitted here

frameData.commandList-&gt;barrier(
    swapChain,
    vireo::ResourceState::RENDER_TARGET_COLOR,
    vireo::ResourceState::PRESENT);
</pre><p> The application can be started to display a black window (since we never write data into the frame buffer): <img src="swap_chain.png" alt="" class="inline" title="swap_chain.png"/>    </p>
<h2>Render pass</h2>
<p>A render pass consists of a list of commands submitted to the GPU to draw into various frame buffers also named attachments. In this tutorial we will directly draw into the swap chain frame buffers.</p>
<p>To configure the attachments and the render pass we have to create a <a href="https://henrimichelon.github.io/Vireo/structvireo_1_1RenderingConfiguration.html">RenderingConfiguration</a>. Add a configuration object to your application class: </p><pre class="fragment">...
vireo::RenderingConfiguration renderingConfig {
    .colorRenderTargets = {{
        .clear = true,
        .clearValue = {0.0f, 0.2f, 0.4f, 1.0f}
    }}
};
...
</pre><p> We declare in this object <em>one</em> frame buffer as a color attachment. The only parameter for this attachment is the RGBA color used to clear the frame buffer before drawing (we need it to be different from the default black color to visually control that the frame buffer clearing is effective).</p>
<p>Since we will render directly into the swap chain we need to set the color attachment target just after the swap chain creation with <code>createSwapChain()</code>: </p><pre class="fragment">...
renderingConfig.colorRenderTargets[0].swapChain = swapChain;
...
</pre><p> In the <code>onRender()</code> method we can start the render pass between the swap chain barriers: </p><pre class="fragment">...
frameData.commandList-&gt;beginRendering(renderingConfig);

// commands will be recorded and submitted here

frameData.commandList-&gt;endRendering();
...
</pre><p> After the white then the black window we now have a blue window : <img src="clear_color.png" alt="" class="inline" title="clear_color.png"/>    </p>
<h2>Viewports and scissors</h2>
<p>A viewport basically describes the region of the framebuffer that the output will be rendered to. This will almost always be (0, 0) to (width, height).</p>
<p>While viewports define the transformation from the image to the framebuffer, scissor rectangles define in which regions pixels will actually be stored. Any pixels outside the scissor rectangles will be discarded by the rasterizer. They function like a filter rather than a transformation (image is from the <a href="https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions">Vulkan tutorial</a>):</p>
<div class="image">
<img src="viewports_scissors.png" alt=""/>
<div class="caption">
viewports_scissors.png</div></div>
    <p>We need to record the commands to set the viewports &amp; scissors at the start of the render pass : </p><pre class="fragment">...
frameData.commandList-&gt;beginRendering(renderingConfig);
frameData.commandList-&gt;setViewport(swapChain-&gt;getExtent());
frameData.commandList-&gt;setScissors(swapChain-&gt;getExtent());
// commands will be recorded and submitted here
...
</pre> <h2>Vertex data</h2>
<p>Our triangle vertices will be hard-coded into the application. Add the struct describing a vertex composed of a XYZ position and an RGB color in your class interface: </p><pre class="fragment">struct Vertex {
    glm::vec3 pos;
    glm::vec3 color;
};
</pre><p> Add the triangle data with a different color for each vertex, after the <code>Vertex</code> struct: </p><pre class="fragment">std::vector&lt;Vertex&gt; triangleVertices{
    { {  0.0f,  0.5f, 0.0f }, { 1.0f, 0.0f, 0.0f } },
    { {  0.5f, -0.5f, 0.0f }, { 0.0f, 1.0f, 0.0f } },
    { { -0.5f, -0.5f, 0.0f }, { 0.0f, 0.0f, 1.0f } }
};
</pre><p> The next step is to tell the graphic API how to pass this data format to the vertex shader once it's been uploaded into GPU memory. We have to describe each field of the <code>Vertex</code> struct using <a href="https://henrimichelon.github.io/Vireo/structvireo_1_1VertexAttributeDesc.html">VertexAttributeDesc</a>, after the triangle data: </p><pre class="fragment">const std::vector&lt;vireo::VertexAttributeDesc&gt; vertexAttributes{
    {"POSITION", vireo::AttributeFormat::R32G32B32_FLOAT, offsetof(Vertex, pos)},
    {"COLOR",    vireo::AttributeFormat::R32G32B32_FLOAT, offsetof(Vertex, color)}
};
</pre><p> This vector is used to create the vertex layout for the future pipeline. Add the following code before the for loop in the <code>onInit()</code> method: </p><pre class="fragment">...
const auto vertexLayout = vireo-&gt;createVertexLayout(sizeof(Vertex), vertexAttributes);

for (auto&amp; frameData : framesData) {
...
</pre><p> We are done with the vertex layout. Now we have to upload the vertex data into the VRAM in a <code>VERTEX</code> buffer. Add the buffer field to your application : </p><pre class="fragment">std::shared_ptr&lt;vireo::Buffer&gt; vertexBuffer;
</pre><p> In the <code>onInit()</code> method, just before the <code>createVertexLayout()</code> line, add the buffer creation : </p><pre class="fragment">vertexBuffer = vireo-&gt;createBuffer(
   vireo::BufferType::VERTEX,
   sizeof(Vertex),
   triangleVertices.size());
</pre><p> We will use a <code>TRANSFER</code> command list to upload the vertex data into the VRAM. You can use a <code>GRAPHIC</code>command list for that but the <code>TRANSFER</code> command buffers and submit queues can take advantage of DMA transfers.</p>
<p>In the <code>onInit()</code> method, just after the buffer creation add the command allocator and command list creation : </p><pre class="fragment">const auto uploadCommandAllocator = vireo-&gt;createCommandAllocator(vireo::CommandType::TRANSFER);
const auto uploadCommandList = uploadCommandAllocator-&gt;createCommandList();
</pre><p> Followed by the recording of the upload command : </p><pre class="fragment">uploadCommandList-&gt;begin();
uploadCommandList-&gt;upload(vertexBuffer, &amp;triangleVertices[0]);
uploadCommandList-&gt;end();
</pre><p> Then the submission of the commands using a <code>TRANSFER</code> submit queue : </p><pre class="fragment">const auto transferQueue = vireo-&gt;createSubmitQueue(vireo::CommandType::TRANSFER);
transferQueue-&gt;submit({uploadCommandList});
</pre><p> Since the upload operation is asynchronous, we have to wait for the command to finish before terminating the <code>onInit()</code> method. Add the following code at the end of the method : </p><pre class="fragment">transferQueue-&gt;waitIdle();
uploadCommandList-&gt;cleanup();
</pre><p> By adding the <code>waitIdle()</code> at the end of the method, the upload operation will be executed while we continue to create our pipeline.</p>
<p>Note that we call the <code>cleanup()</code> method to clear the temporary (staging) buffer used for the host-to-device copy of the vertex data. The asynchronous nature of the operating means that we have to wait for the end of the operation to free the host-visible allocated memory. This is done automatically in the command list destructor, but we added this call in the tutorial for clarification.</p>
<h2>The graphic pipeline</h2>
<p>The graphics pipeline is the sequence of operations that take the vertices and textures of your meshes all the way to the pixels in the render targets. You can learn more about graphics pipelines in the <a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction">Vulkan tutorial</a>. To create a graphic pipeline, we need :</p><ul>
<li>The vertex layout</li>
<li>The shader(s) module(s)</li>
<li>The list of resources (uniform buffers, images, samplers, ...) used by the shaders</li>
<li>The configuration of the pipeline</li>
</ul>
<h3>Shader modules</h3>
<p>We will use the <a href="https://shader-slang.org/">Slang shader language</a> to write our shaders. By using Slang we will have only one code for all the supported graphics API.</p>
<p>The <code>CMakeLists.txt</code> file supports the compilation of the shaders in the SPIR-V and DXIL intermediates formats.</p>
<p>Add a new <code>shaders</code> directory under the <code>src</code> directory, then add a new <code>triangle_color.slang</code> file into the <code>src/shaders</code> directory with the following content : </p><pre class="fragment">struct VertexInput {
   float3 position : POSITION;
   float3 color    : COLOR;
};

struct VertexOutput {
   float4 position : SV_POSITION;
   float3 color    : COLOR;
};

VertexOutput vertexMain(VertexInput input) {
   VertexOutput output;
   output.position = float4(input.position, 1.0) ;
   output.color = input.color;
   return output;
}

float4 fragmentMain(VertexOutput input) : SV_TARGET {
   return float4(input.color, 1.0);
}
</pre><p> The <code>POSITION</code> and <code>COLOR</code> attributes in the <code>VertexInput</code> struct refers to the fields of the <code>vertexAttributes</code> array. Since Vulkan does not use textual attributes names but binding indices the fields must be in the same order in the struct and in the array.</p>
<p>The fragment shader uses the vertex color to produce a nice RGB gradient (the GPU calculates the color interpolation for each fragment/pixel from the vertices colors).</p>
<p>Reload the CMake project to add the new shader code to the list of shaders to compile then build the <code>shaders</code> target.</p>
<p>If you look into the <code>shaders</code> directory in the root of your project you will see four files with the compiled vertex and fragment shaders, both in SPIR-V and DXIL :</p>
<div class="image">
<img src="compiled_shaders.png" alt=""/>
<div class="caption">
compiled_shaders.png</div></div>
    <p>Now we can load the shaders in our <code>onInit()</code> method, just after the vertex layout creation : </p><pre class="fragment">...
const auto vertexLayout = vireo-&gt;createVertexLayout(sizeof(Vertex), vertexAttributes);
const auto vertexShader = vireo-&gt;createShaderModule("shaders/triangle_color.vert");
const auto fragmentShader = vireo-&gt;createShaderModule("shaders/triangle_color.frag");
...
</pre><h3>Pipeline creation</h3>
<p>The graphic pipeline configuration is described in a <a href="https://henrimichelon.github.io/Vireo/structvireo_1_1GraphicPipelineConfiguration.html">GraphicPipelineConfiguration</a> struct.</p>
<p>For rendering in a color attachment you need :</p><ul>
<li>The color format of the attachment</li>
<li>The color blending configuration for this attachment</li>
</ul>
<p>Add a basic configuration in your application with only one color attachment : </p><pre class="fragment">vireo::GraphicPipelineConfiguration pipelineConfig {
   .colorRenderFormats = {vireo::ImageFormat::R8G8B8A8_SRGB},
   .colorBlendDesc = {{}}
};
</pre><p> Then add the pipeline field : </p><pre class="fragment">std::shared_ptr&lt;vireo::Pipeline&gt; pipeline;
</pre><p> and the pipeline creation just after the shader modules creation in <code>onInit()</code>: </p><pre class="fragment">pipelineConfig.resources = vireo-&gt;createPipelineResources();
pipelineConfig.vertexInputLayout = vertexLayout;
pipelineConfig.vertexShader = vertexShader;
pipelineConfig.fragmentShader = fragmentShader;
defaultPipeline = vireo-&gt;createGraphicPipeline(pipelineConfig);
</pre><p> We use an empty pipeline resource object since our shader only uses the vertex input described by the vertex layout.</p>
<h2>Drawing</h2>
<p>It's time to draw our triangle!</p>
<p>Add the drawing commands recording in the <code>onRender()</code> method between <code>setScissors()</code> and <code>endRendering()</code> : </p><pre class="fragment">frameData.commandList-&gt;bindPipeline(pipeline);
frameData.commandList-&gt;bindVertexBuffer(vertexBuffer);
frameData.commandList-&gt;draw(triangleVertices.size());
</pre><p> If you did everything correctly up to this point, then you should now see something resembling the following when you run your program.</p>
<p>With Vulkan :</p>
<div class="image">
<img src="triangle_color_vk.png" alt=""/>
<div class="caption">
triangle_color_vk.png</div></div>
    <p>With DirectX :</p>
<div class="image">
<img src="triangle_color_dx.png" alt=""/>
<div class="caption">
triangle_color_dx.png</div></div>
    <h2>What's next?</h2>
<p>Explore the <a href="https://github.com/HenriMichelon/vireo_samples">Vireo RHI Samples repository</a> for other examples (uniforms, push constants, compute pipeline, MSAA, depth pre-pass, post-processing effects, ...) </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Generated by DoxyPress 2.0.0 -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on mar. mai 6 2025 21:48:54 for Vireo &nbsp; by
    <a href="https://www.copperspice.com/documentation-doxypress.html">
    <img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 2.0.0 </li>
  </ul>
</div>
</body>
</html>
